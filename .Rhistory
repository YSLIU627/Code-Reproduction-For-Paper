knitr::opts_chunk$set(echo = TRUE)
CD <- function(alpha_0,max_iter,sample,loss,loss.grad,w_func,x,y)
{
# x,y are given data
alpha <- alpha_0
w <- w_func(alpha)
iter <- 0
while(iter < max_iter){
direction <- sample(alpha,w,x,y)
# direction is a vector like alpha with only one none zero dim
update <- direction * loss.grad(alpha,x,y,...)
alpha <- alpha + update
w <- w_func(alpha)
}
}
###example
CD()
CD <- function(alpha_0 =0,max_iter,sample,loss,loss.grad,w_func,x,y)
{
# x,y are given data
alpha <- alpha_0
w <- w_func(alpha)
iter <- 0
while(iter < max_iter){
direction <- sample(alpha,w,x,y)
# direction is a vector like alpha with only one none zero dim
update <- direction * loss.grad(alpha,x,y,...)
alpha <- alpha + update
w <- w_func(alpha)
}
}
?norm
svm.loss <- function(alpha,lambda){
n <- length(alpha)
l1 <- 1/n
l2 <- 1*lambda/2
}
svm.gap <- function(alpha,lambda,B,w,A,demension = 1){
# A is a matrix
i <- demension
return(g_conj(-t(A[,i]%*% w)+ g(alpha[i])+alpha[i]*t(A[,i])%*%w)
}
svm.loss <- function(alpha,lambda){
n <- length(alpha)
l1 <- 1/n
l2 <- 1*lambda/2
}
svm.gap <- function(alpha,lambda,B,w,A,y,demension = 1){
# A is a matrix
i <- demension
n <- length(alpha)
g_conj <- function(input,y){
return(input*y/n)
}
g <- function(input,y){
# Not certain
# alpha_i * y_i in [0,1]
return(input * y)
}
return(g_conj(-t(A[,i],y[i])%*% w)+ g(alpha[i],y[i])+alpha[i]* t(A[,i]) %*%w)
}
