alpha0 <- as.matrix(alpha)
# First calculate the subgrad of |alpha|, sub1
if (alpha[i] > 0 ){
sub1 <- 1#alpha[i]/norm(alpha0,type = "O")
}
else if(alpha[i] < 0){
sub1 <- -1#alpha[i]/norm(alpha0,type = "O")
}
else {
seed <- runif(1,-1,1)
sub1 <- lambda*seed #* alpha[i]/norm(alpha0,type = "O")
}
# Then calculate the grad of ||A\alpha -y||^2
term <- vector(length =length(A[,1]))
for (s in 1:n){
term <- term + as.vector(alpha[s]*A[,s])
}
sub2 <- t(A[,i]) %*% term + t(term) %*% A[,i] - t(y) %*% A[,i] - t(A[,i])%*% y
subgrad = sub1 +rowSums(sub2)
#browser()
return(subgrad)
}
lasso.gap <- function(alpha,lambda,B,A,dimension,y){
# 计算对偶gap
# A is a matrix
i <- dimension
#browser()
w <- lasso.w_func(alpha,A,y)
gap <- B*positive(abs(sum(A[,i]* w))- lambda)+lambda*abs(alpha[i])+
alpha[i]*(sum(A[,i]* w))
browser()
return(gap)
}
#CD_each_iter(sample_p = p.uniform,A =diag(1,3,3) ,y = diag(1,3,3)%*%c(1,0,1),lambda = 0.05)
lasso.dualres <- function(alpha,lambda,A,dimension,y){
#计算对偶残差
# first calculate the subgrad of g_i^*
i <- dimension
flag <-  0
eps <- 1e-5
w <- lasso.w_func(alpha, A, y)
input <- -t(A[,i])%*%w
# 这里的g用的是文中修改后的g拔，下面计算次梯度
if (input > eps && input <= B){
g_sub <- lambda *input
}
else if(input < -eps && input >= -B){
g_sub <- -lambda *input
}
else if(abs(input) <B){
g_sub_right <- lambda * abs(input)
g_sub_left  <- -lambda * abs(input)
flag <- 1
#g_sub is an interval
}
else {
g_sub <- Inf
}
# When flag ==0 ,subgrad is grad, otherwise is a interval
if (flag == 0){
return (abs(alpha[i])-g_sub)
}
#  subgrad is a interval
if (abs(alpha[i]) <= g_sub_right){
return (0)
}
else {
return (min(abs(alpha[i]-g_sub_right),abs(alpha[i]-g_sub_left) ))
# Return the closet distance from the interval
}
}
#CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
alpha
CD_each_iter <- function(sample_p,A,y,lambda,...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,size = 1,prob = sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...))
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - update
browser()
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y=y)
}
record.gap[k] <- sum(gap)
#browser()
}
}
return (log(record.gap))
}
#CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_per_epoch <-function(sample_p,A,y,lambda, ...)
{
epoch <- dim(A)[1]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,prob = p)
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - update
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y)
}
record.gap[k] <- sum(gap)
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
}
}
return (log(record.gap))
}
CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
sum(update)
sum(alpha)
sum(direction)
gap
alpha
CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.0)
sum(alpha)
CD_each_iter <- function(sample_p,A,y,lambda,...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,size = 1,prob = sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...))
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - 0.001*update
browser()
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y=y)
}
record.gap[k] <- sum(gap)
#browser()
}
}
return (log(record.gap))
}
#CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_per_epoch <-function(sample_p,A,y,lambda, ...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,prob = p)
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - update
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y)
}
record.gap[k] <- sum(gap)
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
}
}
return (log(record.gap))
}
CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_each_iter <- function(sample_p,A,y,lambda,...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,size = 1,prob = sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...))
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - 1e-10*update
#browser()
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y=y)
}
record.gap[k] <- sum(gap)
browser()
}
}
return (log(record.gap))
}
#CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_per_epoch <-function(sample_p,A,y,lambda, ...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,prob = p)
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - update
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y)
}
record.gap[k] <- sum(gap)
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
}
}
return (log(record.gap))
}
positive <- function(x){
if(x >= 0){
return(x)
}
return(0)
}
lasso.loss <- function(A,alpha,y) {
# 返回loss函数的值
return (norm(A%*%alpha - y,type = "2")+norm("alpha",type = "O"))
}
lasso.w_func <- function(alpha,A,y){
#返回w的函数值
return(2*(A %*% alpha - y))
}
lasso.subgrad <- function(alpha,lambda,A,dimension,y,...){
#返回次梯度
i <- dimension
n <- length(alpha)
alpha0 <- as.matrix(alpha)
# First calculate the subgrad of |alpha|, sub1
if (alpha[i] > 0 ){
sub1 <- 1#alpha[i]/norm(alpha0,type = "O")
}
else if(alpha[i] < 0){
sub1 <- -1#alpha[i]/norm(alpha0,type = "O")
}
else {
seed <- runif(1,-1,1)
sub1 <- lambda*seed #* alpha[i]/norm(alpha0,type = "O")
}
# Then calculate the grad of ||A\alpha -y||^2
term <- vector(length =length(A[,1]))
for (s in 1:n){
term <- term + as.vector(alpha[s]*A[,s])
}
sub2 <- t(A[,i]) %*% term + t(term) %*% A[,i] - t(y) %*% A[,i] - t(A[,i])%*% y
subgrad = sub1 +rowSums(sub2)
#browser()
return(subgrad)
}
lasso.gap <- function(alpha,lambda,B,A,dimension,y){
# 计算对偶gap
# A is a matrix
i <- dimension
#browser()
w <- lasso.w_func(alpha,A,y)
gap <- B*positive(abs(sum(A[,i]* w))- lambda)+lambda*abs(alpha[i])+
alpha[i]*(sum(A[,i]* w))
#browser()
return(gap)
}
#CD_each_iter(sample_p = p.uniform,A =diag(1,3,3) ,y = diag(1,3,3)%*%c(1,0,1),lambda = 0.05)
lasso.dualres <- function(alpha,lambda,A,dimension,y){
#计算对偶残差
# first calculate the subgrad of g_i^*
i <- dimension
flag <-  0
eps <- 1e-5
w <- lasso.w_func(alpha, A, y)
input <- -t(A[,i])%*%w
# 这里的g用的是文中修改后的g拔，下面计算次梯度
if (input > eps && input <= B){
g_sub <- lambda *input
}
else if(input < -eps && input >= -B){
g_sub <- -lambda *input
}
else if(abs(input) <B){
g_sub_right <- lambda * abs(input)
g_sub_left  <- -lambda * abs(input)
flag <- 1
#g_sub is an interval
}
else {
g_sub <- Inf
}
# When flag ==0 ,subgrad is grad, otherwise is a interval
if (flag == 0){
return (abs(alpha[i])-g_sub)
}
#  subgrad is a interval
if (abs(alpha[i]) <= g_sub_right){
return (0)
}
else {
return (min(abs(alpha[i]-g_sub_right),abs(alpha[i]-g_sub_left) ))
# Return the closet distance from the interval
}
}
#CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_each_iter <- function(sample_p,A,y,lambda,...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,size = 1,prob = sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...))
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - 1e-12*update
#browser()
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y=y)
}
record.gap[k] <- sum(gap)
#browser()
}
}
return (log(record.gap))
}
#CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_per_epoch <-function(sample_p,A,y,lambda, ...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,prob = p)
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - update
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y)
}
record.gap[k] <- sum(gap)
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
}
}
return (log(record.gap))
}
CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_each_iter <- function(sample_p,A,y,lambda,...)
{
step0 <- 0.01
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,size = 1,prob = sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...))
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - step0/sqrt(iter)*update
#browser()
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y=y)
}
record.gap[k] <- sum(gap)
#browser()
}
}
return (log(record.gap))
}
#CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
CD_per_epoch <-function(sample_p,A,y,lambda, ...)
{
epoch <- dim(A)[2]
n <- dim(A)[2]
max_iter <- epoch*25
record.gap <- numeric(length=25)
gap <- numeric(n)
# A,y are given data
alpha <- numeric(length = n)
B <- (norm(A%*%alpha - y,type = "2"))/lambda
w <- lasso.w_func(alpha,A,y)
iter <- 0
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
while(iter < max_iter){
iter <- iter+1
i <- sample(1:n,prob = p)
# direction is a sample prob vector like alpha with only one none zero dim
direction = vector(length = n)
direction[i] = 1
update <- direction * lasso.subgrad(alpha = alpha,dimension =i ,A =A,y=y,lambda = lambda)
alpha <- alpha - update
# Record the result
if(iter%%epoch==0){
k <- iter/epoch
for(j in 1:n){
gap[j] <- lasso.gap(alpha, lambda, B, A, j,y)
}
record.gap[k] <- sum(gap)
p <- sample_p(alpha = alpha,A=A,y=y,lambda=lambda,B=B,...)
}
}
return (log(record.gap))
}
CD_each_iter(sample_p = p.uniform,A = A.mushrooms,y = y.mushrooms,lambda = 0.05)
